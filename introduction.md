[üîô Indice](https://github.com/IngSoft-DA2/DA2-Tecnologia/tree/filters?tab=readme-ov-file#indice) -> [üè† Main](https://github.com/IngSoft-DA2/DA2-Tecnologia/tree/main?tab=readme-ov-file#-temas-y-ejemplos-de-c%C3%B3digo)

# ‚ú® Filtros en ASP.NET Core

Los **filtros** en ASP.NET Core permiten ejecutar c√≥digo *antes* y/o *despu√©s* de procesar una solicitud (_request_). Son piezas clave para controlar la l√≥gica en el ciclo de vida de una petici√≥n HTTP dentro de tu aplicaci√≥n web.

---

## üö¶ ¬øC√≥mo funcionan los filtros?

Los filtros son ejecutados por ASP.NET Core como parte de la **pipeline** de procesamiento de una request. En otras palabras, son tareas que se pueden interponer en diferentes etapas del flujo de una petici√≥n.

<div align="center">
  <img src="./images/image.png" alt="Pipeline de tareas"/>
  <br/>
  <strong>Lista de tareas por las cuales pasa una request</strong>
</div>

En la imagen puedes observar las tareas predefinidas del framework:

- **Other Middleware**: Middleware personalizado creado por el desarrollador.
- **Routing Middleware**: Enruta la request hacia el controlador correspondiente.
- **Action Selection**: Selecciona el m√©todo del controlador que ser√° invocado.
- **Filter Pipeline**: Lugar donde los filtros son ejecutados.

---

## üß© Tipos de filtros

Cada filtro se ejecuta en una etapa espec√≠fica de la **pipeline**. Los principales tipos son:

| Tipo           | Descripci√≥n                                                                                             |
|----------------|--------------------------------------------------------------------------------------------------------|
| üîë Authorization | Primeros en ejecutarse. Determinan si el usuario est√° autorizado.                                     |
| üì¶ Resource      | Se ejecutan despu√©s de los Authorization. Permiten l√≥gica antes y despu√©s de los dem√°s filtros.       |
| ‚ö° Action        | Justo antes y despu√©s del m√©todo del controlador. Pueden modificar argumentos y resultados.           |
| üìç Endpoint      | Pueden modificar argumentos y resultados en endpoints de clase y de acci√≥n.                           |
| üí• Exception     | Aplican pol√≠ticas globales para manejar excepciones antes de responder al cliente.                    |
| üìù Result        | Antes y despu√©s de dar una respuesta. √ötiles para l√≥gica de formateo.                                 |

<div align="center">
  <img src="./images/image-1.png" alt="Interacci√≥n entre filtros"/>
  <br/>
  <strong>Interacci√≥n entre filtros</strong>
</div>

---

## üï∞Ô∏è Definici√≥n y orden de ejecuci√≥n

Los filtros pueden aplicarse en diferentes niveles:

- üåç Global (para toda la app)
- üìÇ Controller (para un controlador espec√≠fico)
- üîß M√©todo (para una acci√≥n espec√≠fica)

El **orden de ejecuci√≥n** depende del nivel de alcance:

```plaintext
El c√≥digo de antes en un filtro global
  El c√≥digo de antes de un filtro de controller
    El c√≥digo de antes de un filtro de m√©todo
      C√≥digo a invocar
    El c√≥digo de despu√©s de un filtro de m√©todo
  El c√≥digo de despu√©s de un filtro de controller
El c√≥digo de despu√©s de un filtro global
```

### Ejemplo: Orden en la ejecuci√≥n

| Secuencia | Alcance del filtro | M√©todo del filtro      |
|-----------|-------------------|-----------------------|
| 1         | Global            | OnActionExecuting     |
| 2         | Controller        | OnActionExecuting     |
| 3         | M√©todo            | OnActionExecuting     |
| 4         | -                 | C√≥digo                |
| 5         | M√©todo            | OnActionExecuted      |
| 6         | Controller        | OnActionExecuted      |
| 7         | Global            | OnActionExecuted      |

---

## üî¢ Sobrescribir el orden de ejecuci√≥n

Puedes modificar el orden usando la interfaz `IOrderedFilter` y su propiedad `Order`.

- Filtros con menor valor en `Order` se ejecutan primero.
- Filtros con mayor valor en `Order` se ejecutan despu√©s.

#### Ejemplo

```csharp
[SampleActionFilter(Order = int.MinValue)]
public class ControllerFiltersController : Controller
{
    // ...
}
```

```csharp
builder.Services.AddControllers(options =>
{
    options.Filters.Add<GlobalSampleActionFilter>(int.MaxValue);
});
```

As√≠, el filtro con `Order = int.MinValue` se ejecuta antes que el de `int.MaxValue`, independientemente del alcance.

---

## ‚úã Cancelar ejecuci√≥n de un filtro

Un filtro puede interrumpir el procesamiento de la request en cualquier momento, asignando un valor a la propiedad `Result` del par√°metro `context`.

---

## üßë‚Äçüîß Filtros con dependencias

- **Por instancia**: La misma instancia se usa para cada request.
- **Por tipo**: Se crea una nueva instancia para cada request (con dependencias inyectadas desde el contenedor de servicios).

### üö® Importante
Los filtros agregados como atributos directamente a nivel de controlador o m√©todo no pueden tener constructores con dependencias para inyecci√≥n autom√°tica.

---

## üõ†Ô∏è ServiceFilterAttribute

Permite obtener una instancia del filtro desde el contenedor de servicios (*Dependency Injection*).

**Definici√≥n del filtro:**

```csharp
public class CustomFilterService(IMyDependency dependency) : IActionFilter
{
    public void OnActionExecuting(ResultExecutingContext context)
    {
      dependency.Action();
    }
    public void OnActionExecuted(ResultExecutedContext context)
    {
      dependency.Action();
    }
}
```

**Registro en Program.cs**

```csharp
builder
.Services
.AddScoped<CustomFilterService>()
.AddScoped<IMyDependency, MyDependency>();
```

**Uso en metodo de controller**

```csharp
[ServiceFilter<CustomFilterService>(IsReusable = false)]
public void MyActionOnController()
{
  // ...
}
```

---

## üß¨ TypeFilterAttribute

Similar al anterior, pero el tipo del filtro no es resuelto por el contenedor DI, sino que se instancia manualmente. Permite pasar argumentos al filtro.

**Definici√≥n del filtro:**

```csharp
public class CustomFilterService(
IMyDependency dependency,
string parameter1,
string parameter2)
: IActionFilter
{
    // ...
}
```

**Registro en Program.cs**

```csharp
builder
.Services
.AddScoped<IMyDependency, MyDependency>();
```

**Uso en metodo de controller:**

```csharp
[TypeFilter(typeof(CustomFilter), Arguments = ['custom','arguments'], IsReusable = false)]
public void MyActionOnController()
{
  // ...
}
```

> Apesar de que el tipo del servicio (el filtro en si: CustomFilter en este caso) en TypeFilterAttribute no necesita ser declarado en el contenedor de servicios, sus dependencias si van a ser resueltas usando este y opcionalmente aceptar otros argumentos en el constructor resueltos por TypeFilterAttribute

---

## üè∑Ô∏è Filtros como atributos

- Deben heredar de `Attribute`.
- El constructor debe ser sin par√°metros (o con par√°metros proporcionales).
- **No** permiten inyecci√≥n autom√°tica de dependencias.

**Ejemplo:**

```csharp
public sealed class CustomFilterAttribute : Attribute, // indicar tipo de filtro implementando la interfaz correspondiente
{
  // ...
}
```

**Uso:**

```csharp
[ApiController]
[Route("endpoints")]
[CustomFilter]
public sealed class MyController : ControllerBase
{
  [HttpGet]
  [CustomFilter]
  public void MyAction()
  {
    // ...
  }
}
```

Si necesita dependencias, debe obtenerlas manualmente:

```csharp
public sealed class CustomFilterAttribute : Attribute // tipo de filtro
{
  public void FilterFunction(FilterContext context)
  {
    var dependency = context.HttpContext.RequestServices.GetRequiredService<IMyDependency>();
  }
}
```

> ‚úÖ Aqu√≠ puedes usar cualquier ciclo de vida para la dependencia.

---

# ‚ö°Ô∏è Filtros vs Middlewares en ASP.NET Core

En ASP.NET Core, tanto los **filtros** como los **middlewares** permiten ejecutar l√≥gica personalizada durante el procesamiento de una solicitud HTTP. Sin embargo, tienen diferencias clave en su prop√≥sito y aplicaci√≥n.

---

## üß† ¬øQu√© son?

| Concepto      | Middleware                                                                                         | Filtro                                                                                          |
|---------------|---------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| Definici√≥n    | Componente que se encadena en la pipeline HTTP para procesar requests/responses.                  | Componente que se ejecuta en etapas espec√≠ficas dentro del ciclo MVC (antes/despu√©s de acciones) |
| Alcance       | Global, afecta todas las requests.                                                                | Puede ser global, por controlador o por acci√≥n espec√≠fica.                                      |
| Contexto      | Trabaja a nivel de la request completa (antes de llegar a MVC).                                   | Trabaja dentro del contexto MVC (Controllers y Actions).                                        |
| Tipos         | Request, Response, Custom.                                                                        | Authorization, Resource, Action, Result, Exception, Endpoint.                                   |

---

## üìù Ejemplo Visual

```plaintext
Request
  ‚Üì
[Middlewares]
  ‚Üì
[Routing]
  ‚Üì
[Controllers]
  ‚Üì
[Filtros]
  ‚Üì
[Action Methods]
  ‚Üì
Response
```

---

## üîç Diferencias Clave

- **Middlewares**
  - Se ejecutan desde que la request entra a la aplicaci√≥n hasta que sale la respuesta.
  - Son ideales para l√≥gica transversal (logging, autenticaci√≥n, CORS, manejo de errores global).
  - Se configuran en el archivo `Program.cs` o `Startup.cs`.
  - No tienen conocimiento espec√≠fico del MVC ni de acciones.

- **Filtros**
  - Se ejecutan en puntos espec√≠ficos del ciclo MVC (antes/despu√©s de acciones, resultados, excepciones).
  - Permiten l√≥gica m√°s granular y relacionada a la ejecuci√≥n de controladores y acciones (autorizaci√≥n, validaci√≥n de modelos, formateo de respuestas).
  - Pueden aplicarse globalmente, por controlador o por acci√≥n.
  - Acceden al contexto de la acci√≥n, al modelo y a los resultados.

---

## üöÄ ¬øCu√°ndo usar cada uno?

| Usar Middleware para...                  | Usar Filtro para...                               |
|------------------------------------------|---------------------------------------------------|
| Autenticaci√≥n/Autorizaci√≥n global        | Autorizaci√≥n en acciones espec√≠ficas              |
| Manejo de errores global                 | Manejo de excepciones en acciones                 |
| Logging, monitoring                      | Validaci√≥n de modelos en acciones                 |
| Manipulaci√≥n de headers/cookies globales | Modificaci√≥n de resultados de acciones            |
| CORS                                     | L√≥gica que depende del contexto de Controller/Action |

---

## ü§î Ejemplo de Middleware

```csharp
app.Use(async (context, next) =>
{
    // L√≥gica antes de la request
    await next.Invoke();
    // L√≥gica despu√©s de la response
});
```

## üß© Ejemplo de Filtro

```csharp
public class CustomActionFilter : IActionFilter
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        // L√≥gica antes de la acci√≥n
    }
    public void OnActionExecuted(ActionExecutedContext context)
    {
        // L√≥gica despu√©s de la acci√≥n
    }
}
```

---

## üåç ¬øQu√© son los CORS?

**CORS** (*Cross-Origin Resource Sharing*) es un mecanismo de seguridad en los navegadores web que controla c√≥mo las p√°ginas pueden hacer solicitudes a recursos que est√°n en diferentes dominios, protocolos o puertos.

Por defecto, los navegadores bloquean las solicitudes "cross-origin" para proteger la informaci√≥n del usuario. Sin embargo, con CORS, un servidor puede indicar expl√≠citamente qu√© fuentes externas tienen permiso para acceder a sus recursos.

> **Ejemplo:**  
> Si tu aplicaci√≥n web est√° en `https://midominio.com` y necesita consumir una API en `https://api.otrodominio.com`, el servidor de la API debe habilitar CORS para permitir esa comunicaci√≥n.

---

**En resumen:**  
CORS es la manera en que los servidores y navegadores gestionan las solicitudes entre diferentes or√≠genes, manteniendo la seguridad y permitiendo integraci√≥n entre sistemas web distribuidos.

---

## üåê Ejemplo de configuraci√≥n de Middleware `UseCors` para aceptar cualquier verbo, header y origen

Para aceptar **todas** las solicitudes HTTP, sin restricciones de verbo, header ni origen, puedes configurar el middleware CORS en tu aplicaci√≥n ASP.NET Core de la siguiente manera:

```csharp
using Microsoft.AspNetCore.Builder;

var builder = WebApplication.CreateBuilder(args);

// Configura CORS para permitir cualquier origen, m√©todo y header
builder.Services.AddCors(options =>
{
    options.AddPolicy("Permisivo", policy =>
    {
        policy
            .AllowAnyOrigin()    // Permite cualquier origen
            .AllowAnyMethod()    // Permite cualquier verbo HTTP (GET, POST, PUT, DELETE, etc.)
            .AllowAnyHeader();   // Permite cualquier header
    });
});

var app = builder.Build();

// Aplica el middleware CORS con la pol√≠tica permisiva
app.UseCors("Permisivo");

// ... otros middlewares y configuraci√≥n

app.MapControllers();
app.Run();
```

### üõ°Ô∏è Advertencia

> **Permitir cualquier origen, m√©todo y header puede exponer tu aplicaci√≥n a riesgos de seguridad.**  
> Utiliza esta configuraci√≥n solo en entornos de desarrollo, pruebas, o APIs p√∫blicas donde no hay informaci√≥n sensible involucrada.

---

## üõ†Ô∏è Configuraci√≥n de Middleware CORS: ¬øQu√© implica cada forma?

### 1Ô∏è‚É£ Usando `AddCors` + Pol√≠tica nombrada

Cuando configuras CORS usando `builder.Services.AddCors` con una pol√≠tica nombrada y luego la aplicas mediante `app.UseCors("Permisivo")`, est√°s:

- **Definiendo expl√≠citamente una pol√≠tica CORS** en el contenedor de servicios.
- Permitiendo reutilizar esa pol√≠tica en diferentes partes de tu aplicaci√≥n.
- Facilitando la gesti√≥n centralizada y el mantenimiento de reglas CORS.
- Permitiendo que puedas tener **m√∫ltiples pol√≠ticas CORS** y seleccionar cu√°l aplicar en cada endpoint o globalmente.

**Ejemplo:**
```csharp
// Definici√≥n de la pol√≠tica
builder.Services.AddCors(options =>
{
    options.AddPolicy("Permisivo", policy =>
    {
        policy.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader();
    });
});

// Aplicaci√≥n global de la pol√≠tica
app.UseCors("Permisivo");
```

#### ‚úÖ Ventajas

- **Reutilizable:** Puedes aplicar la pol√≠tica por nombre en diferentes lugares (globalmente, por endpoint, por controlador).
- **Escalable:** F√°cil de mantener si en el futuro necesitas reglas m√°s restrictivas o m√∫ltiples pol√≠ticas.
- **Centralizado:** Todas las reglas CORS est√°n en un solo lugar.

---

### 2Ô∏è‚É£ Configurando directamente en `app.UseCors`

Tambi√©n puedes configurar el middleware CORS directamente en el pipeline, sin definir primero una pol√≠tica nombrada. Por ejemplo:

```csharp
app.UseCors(policy =>
    policy.AllowAnyOrigin()
          .AllowAnyMethod()
          .AllowAnyHeader()
);
```

#### üîé ¬øQu√© implica esta forma?

- La configuraci√≥n es **inline** en el momento de agregar el middleware.
- **No puedes reutilizar la pol√≠tica** f√°cilmente en otros lugares.
- **Menos escalable** si tu aplicaci√≥n crece y necesita diferentes configuraciones CORS para distintos endpoints.
- La gesti√≥n de las reglas CORS est√° **dispersa** si tienes m√°s de un `UseCors` en distintos lugares.

---

## ‚öñÔ∏è Comparaci√≥n

| Aspecto                | Pol√≠tica Nombrada (`AddCors` + `UseCors("nombre")`) | Configuraci√≥n Directa (`UseCors`)        |
|------------------------|-----------------------------------------------------|------------------------------------------|
| Reutilizaci√≥n          | ‚úÖ S√≠, puedes aplicar por nombre                     | ‚ùå No, solo donde la defines              |
| Mantenimiento          | ‚úÖ Centralizado y m√°s f√°cil de modificar             | ‚ùå M√°s dif√≠cil si tienes varias reglas    |
| Escalabilidad          | ‚úÖ Ideal para apps grandes con m√∫ltiples pol√≠ticas   | ‚ùå Mejor para apps simples                |
| Flexibilidad           | ‚úÖ Puedes tener muchas pol√≠ticas distintas           | ‚ùå Solo una configuraci√≥n por llamada     |
| Lectura del c√≥digo     | ‚úÖ M√°s claro y organizado                            | ‚ùå Puede ser confuso si hay varios        |

---

## ‚ö†Ô∏è Consideraciones de Seguridad

**Permitir cualquier origen, m√©todo y header** (como se muestra en ambos ejemplos) expone tu API a cualquier solicitud externa, lo que puede ser un **riesgo de seguridad**. Solo se recomienda en entornos de desarrollo o APIs p√∫blicas bien controladas.

---

> **Resumen:**  
> Usa la configuraci√≥n de pol√≠tica nombrada con `AddCors` si buscas flexibilidad, mantenimiento a largo plazo y claridad en tu aplicaci√≥n.  
> La configuraci√≥n directa con `UseCors` es r√°pida pero menos escalable y reutilizable.

---

## üßë‚Äçüíª Aplicar la pol√≠tica CORS en el controlador o acci√≥n

Adem√°s de aplicar la pol√≠tica CORS globalmente con `app.UseCors("Permisivo")`, puedes aplicarla **directamente en un controlador o acci√≥n espec√≠fica** usando el atributo `[EnableCors]`. Esto te permite tener **mayor granularidad** y controlar el acceso CORS por endpoint.

### 1Ô∏è‚É£ Definir la pol√≠tica con `AddCors`

```csharp
builder.Services.AddCors(options =>
{
    options.AddPolicy("Permisivo", policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyMethod()
              .AllowAnyHeader();
    });
});
```

### 2Ô∏è‚É£ Aplicar la pol√≠tica en el controlador

```csharp
using Microsoft.AspNetCore.Cors;

[ApiController]
[Route("[controller]")]
[EnableCors("Permisivo")] // Aplica la pol√≠tica solo a este controlador
public class SampleController : ControllerBase
{
    [HttpGet]
    public IActionResult Get()
    {
        return Ok("CORS aplicado solo aqu√≠ üö¶");
    }
}
```

### 3Ô∏è‚É£ Aplicar la pol√≠tica en una acci√≥n espec√≠fica

```csharp
using Microsoft.AspNetCore.Cors;

[ApiController]
[Route("[controller]")]
public class AnotherController : ControllerBase
{
    [HttpGet]
    [EnableCors("Permisivo")] // Aplica la pol√≠tica solo a esta acci√≥n
    public IActionResult GetData()
    {
        return Ok("CORS aplicado solo a esta acci√≥n ‚ú®");
    }
}
```

---

## üö© Resumen

- Puedes definir m√∫ltiples pol√≠ticas CORS con `AddCors`.
- Usa `[EnableCors("NombreDeLaPolitica")]` para aplicar una pol√≠tica espec√≠fica en un controlador o acci√≥n.
- Si tienes `app.UseCors("Permisivo")`, la pol√≠tica se aplica globalmente, pero puedes sobrescribirla por endpoint usando `[EnableCors]`.
- Para deshabilitar CORS en un controlador/acci√≥n, usa `[DisableCors]`.

> ¬°As√≠ logras control total y seguro sobre el acceso CORS en tu aplicaci√≥n! üîêüåç

---

## üìö Recursos

- [Middlewares en ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware?view=aspnetcore-8.0)
- [Filtros en ASP.NET Core - Documentaci√≥n oficial](https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-8.0)

---

> ¬°Usa middlewares para l√≥gica transversal y filtros para control granular dentro de MVC! üõ°Ô∏è‚ú®
> 
> ¬°Domina los filtros y lleva el control total sobre el flujo de tu aplicaci√≥n ASP.NET Core! üöÄ
