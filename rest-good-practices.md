[üìç ¬øQu√© es un Endpoint?](https://github.com/IngSoft-DA2/DA2-Tecnologia/blob/web-api/web-api.md#-qu%C3%A9-es-un-endpoint) ‚Üí [üîô Indice](https://github.com/IngSoft-DA2/DA2-Tecnologia/tree/web-api?tab=readme-ov-file#indice) ‚Üí [üè† Main](https://github.com/IngSoft-DA2/DA2-Tecnologia/tree/main?tab=readme-ov-file#da2-tecnologia--dise%C3%B1o-de-aplicaciones-2)

# üåü Buenas Pr√°cticas REST para el Dise√±o de APIs

Las pr√°cticas marcadas con un asterisco (\*) son esenciales y siempre deben respetarse. El resto son recomendaciones √∫tiles para lograr APIs m√°s intuitivas, robustas y f√°ciles de mantener.

---

## 1Ô∏è‚É£ Endpoint/Recurso (\*)

üîó Un **endpoint** es una direcci√≥n √∫nica dentro de una API utilizada para acceder a un recurso o ejecutar una acci√≥n espec√≠fica. T√©cnicamente, un endpoint se identifica mediante una **URI** (Uniform Resource Identifier), que es una cadena que permite identificar un recurso en Internet.  
Dentro de las URIs existen dos conceptos: **URL** (Uniform Resource Locator) y **URN** (Uniform Resource Name):

- **URI**: Es un identificador gen√©rico para cualquier recurso en la web.  
- **URL**: Es un tipo de URI que, adem√°s de identificar el recurso, indica c√≥mo acceder a √©l (es decir, incluye el esquema/protocolo, como http, https, ftp, etc., adem√°s de la direcci√≥n concreta del recurso).  
- **URN**: Es otro tipo de URI que identifica un recurso por nombre dentro de un espacio de nombres, pero no necesariamente indica c√≥mo localizarlo.

En la pr√°ctica, cuando hablamos de endpoints en APIs REST, generalmente nos referimos a **URLs** (por ejemplo, `https://api.misitio.com/users/1`), ya que especifican tanto la ubicaci√≥n como el m√©todo de acceso al recurso.

### üìù Reglas clave:
- **üì¶ Usa sustantivos, no verbos:**  
  - ‚úÖ `/dogs`, `/users`, `/sessions`  
  - ‚ùå `/getAllLeashedDogs`, `/getHungerLevel`
- **üî§ Nombres en plural y min√∫scula:**  
  - ‚úÖ `/admins`, `/dogs`  
  - ‚ùå `/persons`, `/animals`
- **ü™ù Relaciona recursos con jerarqu√≠a:**  
  - ‚úÖ `/owners/1/dogs`  
  - ‚ùå `/users/1/dogs/2`
- **‚ùì Oculta la complejidad usando query params:**  
  - ‚úÖ `/dogs?leashed=true`
- **üö´ No uses verbos en la URI:**  
  - ‚ùå `/getAllLeashedDogs`
- **üìè Limita a 3 niveles de profundidad:**  
  - ‚úÖ `/owners/1/dogs/5`
  - ‚ùå `/a/b/c/d/e`

> Es recomendable mantener las URIs (y por ende las URLs) intuitivas, simples, concretas y evitar nombres abstractos.

### üí° Ejemplo de implementaci√≥n:
```http
GET /users/42/dogs?leashed=true
```
Obtiene todos los perros con correa del usuario 42.

---

## 2Ô∏è‚É£ Verbos HTTP (\*)

REST utiliza los verbos HTTP para definir la acci√≥n sobre el recurso. Los principales son:

- **GET:** Obtener recursos (idempotente)
- **POST:** Crear recursos (no idempotente)
- **PUT:** Reemplazar recursos (idempotente)
- **PATCH:** Modificar parcialmente recursos (no siempre idempotente)
- **DELETE:** Eliminar recursos (idempotente en la mayor√≠a de los casos, pero puede variar)

---

### ‚ö° ¬øQu√© es la idempotencia y por qu√© es importante?

La idempotencia es una propiedad clave en las APIs REST y se refiere a que el resultado de ejecutar una operaci√≥n una o varias veces es el mismo:  
> Un verbo es idempotente si el efecto de realizar una request es el mismo que realizar muchas requests id√©nticas.  
> Esto permite que los clientes puedan repetir una petici√≥n sin temor a producir efectos secundarios no deseados, lo cual resulta fundamental en entornos donde pueden ocurrir problemas de red, timeouts o reintentos autom√°ticos.

#### üîπ Ejemplos pr√°cticos de idempotencia en HTTP:

- **GET, PUT y DELETE** son considerados idempotentes en la mayor√≠a de las implementaciones:
  - **GET**: Leer un recurso varias veces no cambia el estado del servidor.
  - **PUT**: Si env√≠as varias veces la misma actualizaci√≥n, el recurso queda en el mismo estado.

- **DELETE**:  
  Generalmente se considera idempotente, pero esto depende de la implementaci√≥n:
  - Si el DELETE realiza un "soft delete" (por ejemplo, marca el recurso como borrado), entonces repetir la operaci√≥n no cambiar√° el estado tras la primera vez, y la respuesta podr√≠a ser 204 (No Content) o 404 (Not Found) sin afectar el estado interno.  
  - Si el DELETE realiza un "hard delete" y realmente elimina el recurso de forma irreversible, entonces m√∫ltiples DELETE pueden no ser idempotentes si la implementaci√≥n arroja un error o un estado inconsistente tras la primera eliminaci√≥n.  
  - Por esto, la idempotencia de DELETE debe analizarse seg√∫n la l√≥gica de borrado implementada.

- **PUT**: Tambi√©n es idempotente, ya que aplicar la misma modificaci√≥n varias veces deja el estado del recurso igual: una o varias requests con los mismos valores no generan variaciones secundarias.

- **POST**: No es idempotente. Realizar m√∫ltiples requests POST con la misma informaci√≥n crear√° m√∫ltiples instancias del recurso, lo que puede llevar a duplicidad de datos e inconsistencias en la persistencia.

#### üî∏ ¬øPor qu√© es importante la idempotencia?
- Permite a los clientes reintentar operaciones seguras ante fallos de red sin temor a cambiar el estado del sistema involuntariamente.
- Facilita la confiabilidad, robustez y predictibilidad de las aplicaciones distribuidas.
- Reduce riesgos de corrupci√≥n o duplicidad de datos frente a reintentos autom√°ticos o usuarios impacientes.
- Es una base para implementar mecanismos de retry autom√°ticos y sistemas tolerantes a fallos.

### üí° Ejemplo de uso:
```http
POST /products
{
  "nombre": "Teclado Mec√°nico"
}
```
Crea un nuevo producto.  
```http
DELETE /products/7
```
Elimina el producto con ID 7.

---

## 3Ô∏è‚É£ Manejo de errores (\*)

Los mensajes de error deben ser claros, √∫tiles y consistentes, sin revelar informaci√≥n sensible.

‚ú® **Buenas pr√°cticas y consideraciones clave:**

- Los mensajes de error deben proveer la informaci√≥n suficiente para que el error pueda ser resuelto en una request posterior, pero sin exponer vulnerabilidades de seguridad.
- Estos errores ser√°n interpretados tanto por personas con rol desarrollador como por sistemas autom√°ticos. Es importante pensar en qui√©n recibir√° el mensaje para dise√±arlo de forma clara y f√°cil de interpretar.
- La API es una caja negra para los consumidores, por lo que tanto respuestas exitosas como de error deben ser informativas y consistentes.
- Un buen manejo de errores permite adoptar metodolog√≠as como **test-first** y **test-driven development**, facilitando el desarrollo robusto.
- Es fundamental cumplir ciertas reglas para lograr un dise√±o de errores efectivo:

  - **üî¢ Uso correcto de c√≥digos de estado HTTP:**  
    Utiliza c√≥digos que representen claramente el tipo de error ocurrido. Existen m√°s de [70 c√≥digos HTTP](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes), pero no es necesario usarlos todos. Lo ideal es seleccionar un set representativo de cada familia y los m√°s conocidos, como:
    - 200 OK  
    - 201 Created  
    - 204 No Content  
    - 400 Bad Request  
    - 401 Unauthorized  
    - 403 Forbidden  
    - 404 Not Found  
    - 409 Conflict  
    - 500 Internal Server Error

  - **üì¶ Estructura de error consistente:**  
    Una vez definida la estructura del error, debe mantenerse igual para todos los errores, facilitando el manejo en los clientes. Incluye siempre campos como `code`, `message` y, si es necesario, `details`.

### üí° Ejemplo de respuesta de error:
```json
{
  "code": 404,
  "message": "Usuario no encontrado",
  "details": "No existe un usuario con el ID provisto."
}
```

---

## 4Ô∏è‚É£ Funcionalidades no relacionadas a recursos (\*)

üî¢üåê En ocasiones, existen funcionalidades en una API que no est√°n asociadas directamente a un recurso, sino que representan una acci√≥n o c√°lculo sobre datos. Ejemplos de esto pueden ser conversiones de moneda, c√°lculos financieros, traducciones de lenguaje, entre otros.

Estas funcionalidades, a diferencia de los recursos tradicionales, responden con un **resultado** y no con un recurso propiamente dicho.  
En estos casos, es v√°lido utilizar **verbos** en la URI (por ejemplo: `/convert`, `/translate`), pero se recomienda que estos verbos sean lo m√°s simples, claros y directos posible, evitando frases largas o descripciones complejas.

### üí° Ejemplo:
```http
GET /convert?from=EUR&to=CNY&amount=100
```
Convierte 100 euros a yuanes.

> üìë Es fundamental documentar estos endpoints detalladamente, explicando qu√© par√°metros aceptan y cu√°l es el resultado esperado, ya que, al no ser est√°ndar, los usuarios de la API pueden no saber c√≥mo utilizarlos correctamente.

---

## 5Ô∏è‚É£ Versionado

El **versionado** permite cambiar la API sin afectar a los clientes existentes.

El versionado es la pr√°ctica de gestionar distintas versiones de los endpoints de una API para poder introducir cambios de manera segura, manteniendo la compatibilidad hacia atr√°s (backward compatibility) para los clientes que ya usan la API. A medida que la API evoluciona, pueden realizarse cambios en los cuerpos de las requests y responses, as√≠ como en los propios endpoints.  
Para evitar que los clientes existentes se vean afectados por estos cambios, el versionado introduce un control expl√≠cito sobre ellos, permitiendo que los clientes sigan funcionando correctamente sin verse impactados por los nuevos comportamientos.

Adem√°s, el versionado facilita una transici√≥n gradual hacia nuevas versiones, permitiendo un rollout progresivo de los cambios. Esto ofrece una forma clara de interacci√≥n entre los cambios de la API y los clientes, brindando estabilidad y previsibilidad.  
Es esencial manejar el versionado con cuidado para evitar problemas como la fragmentaci√≥n de la API, confusiones en el uso y un aumento innecesario en los esfuerzos de mantenimiento.

### üî¢ Formas de versionar:
- En la URI: `/v1/products`
- En query params: `/products?version=1`
- En headers: `Accept: application/vnd.example.v1+json`

### üí° Ejemplo:
```http
GET /v2/products
```
Obtiene productos usando la versi√≥n 2 de la API.

---

## 6Ô∏è‚É£ Respuestas parciales

Permite que el cliente solicite solo ciertos campos del recurso para optimizar el tr√°fico y el procesamiento. Esto puede ser una ventaja para mejorar la eficiencia del env√≠o de datos y reducir procesamiento tanto del lado del servidor como del cliente.

Las respuestas parciales tratan sobre retornar √∫nicamente un set de propiedades solicitadas para la response, en vez de retornar todas las propiedades programadas a retornar.  
La forma de implementar respuestas parciales puede variar, por ejemplo usando query parameters donde se especifican los campos a incluir.

### üí° Ejemplo:
```http
GET /users/42?fields=name,email
```
Solo retorna el nombre y el email del usuario.

> La implementaci√≥n de respuesta parcial requiere una consideraci√≥n sobre el dise√±o de la API y las necesidades de los clientes. Puede mejorar la eficiencia del env√≠o de la data y reducir procesamiento.  
> Es importante documentar claramente c√≥mo utilizar esta funcionalidad y qu√© campos pueden solicitarse.

---

## 7Ô∏è‚É£ Paginaci√≥n

La **paginaci√≥n** es esencial en APIs que devuelven grandes cantidades de datos, ya que:
- üî• Reduce la carga en el servidor y el cliente
- üöÄ Mejora la performance y la experiencia de usuario
- üìä Facilita el manejo y visualizaci√≥n de grandes colecciones

La paginaci√≥n es la soluci√≥n para reducir un set largo de data a uno m√°s corto y manejable. Un objeto de paginaci√≥n es una mejora significante en la performance y reducci√≥n de carga de datos innecesarios.  
Para asegurar consistencia de los datos en caso de querer filtrar y ordenar, se debe implementar estas acciones de forma previa a la paginaci√≥n. La paginaci√≥n debe ser el √∫ltimo paso antes de retornar los datos.

**¬øC√≥mo debe ser la respuesta?**
Una respuesta paginada debe incluir:
- Un arreglo con los elementos de la p√°gina solicitada
- El n√∫mero total de p√°ginas (`totalPages`)
- El n√∫mero total de elementos (`totalElements`)
- El n√∫mero de la p√°gina actual (`page`)
- El tama√±o de p√°gina (`pageSize`)

### üí° Ejemplo de respuesta paginada:
```json
{
  "elements": [
    { "id": 1, "name": "Producto 1" },
    { "id": 2, "name": "Producto 2" }
  ],
  "page": 1,
  "pageSize": 2,
  "totalPages": 5,
  "totalElements": 10
}
```

### üìù Par√°metros t√≠picos de paginaci√≥n:
- `page` y `pageSize`
- `offset` y `limit`

### üî¢ ¬øC√≥mo se calcula la paginaci√≥n?
Para obtener el √≠ndice del primer elemento de una p√°gina:
```
startIndex = (page - 1) * pageSize
```
Ejemplo: Para la p√°gina 3 y pageSize de 10, el primer elemento es el (3-1)*10 = 20.

El n√∫mero de p√°ginas se calcula como:
```
totalPages = Math.ceil(totalElements / pageSize)
```

> Para asegurar consistencia de los datos en caso de querer filtrar y ordenar, se debe implementar estas acciones de forma previa a la paginaci√≥n. La paginaci√≥n debe ser el √∫ltimo paso antes de retornar los datos.

### üí° Ejemplo de requests:
```http
GET /products?page=2&pageSize=5
```
Devuelve los productos de la p√°gina 2, 5 por p√°gina.

```http
GET /products?offset=3&limit=10
```
Devuelve desde el elemento 4, 10 elementos.

### üßë‚Äçüíª Ejemplo de implementaci√≥n en C#:
```csharp
public Pagination<Entity> Pagination(int pageNumber, int pageSize)
{
    var elements = collection
      .Skip((pageNumber - 1) * pageSize)
      .Take(pageSize)
      .ToList();

    var totalElements = collection.Count;
    var amountOfPages = (int)Math.Ceiling((double)totalElements / pageSize);

    return new Pagination<Entity>(elements, amountOfPages, totalElements);
}
```

### üîé Otros ejemplos avanzados

#### Filtrado y paginaci√≥n
```csharp
public Pagination<Entity> Pagination(int pageNumber, int pageSize)
{
    var elements = collection
      .Where(e => true)
      .Skip((pageNumber - 1) * pageSize)
      .Take(pageSize)
      .ToList();

    var totalElements = collection.Count;
    var amountOfPages = (int)Math.Ceiling((double)totalElements / pageSize);

    return new Pagination<Entity>(elements, amountOfPages, totalElements);
}
```

#### Filtrado, orden y paginaci√≥n
```csharp
public Pagination<Entity> Pagination(int pageNumber, int pageSize)
{
    var elements = collection
      .Where(e => e.Prop == prop)
      .OrderBy(e => e.Prop)
      .Skip((pageNumber - 1) * pageSize)
      .Take(pageSize)
      .ToList();

    var totalElements = collection.Count;
    var amountOfPages = (int)Math.Ceiling((double)totalElements / pageSize);

    return new Pagination<Entity>(elements, amountOfPages, totalElements);
}
```

#### Filtrado, orden, agrupaci√≥n y paginaci√≥n
```csharp
public Pagination<Entity> Pagination(int pageNumber, int pageSize)
{
    var elements = collection
      .Where(e => e.Prop == prop)
      .GroupBy(e => e.Prop)
      .OrderBy(e => e.Key)
      .Select(e => new {
        Prop = e.Key,
        Amount = e.Count()
      })
      .Skip((pageNumber - 1) * pageSize)
      .Take(pageSize)
      .ToList();

    var totalElements = collection.Count;
    var amountOfPages = (int)Math.Ceiling((double)totalElements / pageSize);

    return new Pagination<Entity>(elements, amountOfPages, totalElements);
}
```

**üîó Es fundamental implementar la paginaci√≥n al final de cualquier operaci√≥n de filtrado, orden o agrupamiento para asegurar la consistencia y precisi√≥n de los datos retornados.**

---

## üìö Lecturas recomendadas

- [Dise√±o de API - Ebook](https://aulas.ort.edu.uy/pluginfile.php/441401/mod_resource/content/1/api-design-ebook-2012-03.pdf)

---
